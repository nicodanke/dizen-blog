{"ast":null,"code":"import { Fragment, isValidElement, cloneElement, createElement, Children } from 'react';\nimport { keyFromSelector } from 'i18next';\nimport HTML from 'html-parse-stringify';\nimport { isObject, isString, warn, warnOnce } from './utils.js';\nimport { getDefaults } from './defaults.js';\nimport { getI18n } from './i18nInstance.js';\n\nconst hasChildren = (node, checkLength) => {\n  if (!node) return false;\n  const base = node.props?.children ?? node.children;\n  if (checkLength) return base.length > 0;\n  return !!base;\n};\n\nconst getChildren = node => {\n  if (!node) return [];\n  const children = node.props?.children ?? node.children;\n  return node.props?.i18nIsDynamicList ? getAsArray(children) : children;\n};\n\nconst hasValidReactChildren = children => Array.isArray(children) && children.every(isValidElement);\n\nconst getAsArray = data => Array.isArray(data) ? data : [data];\n\nconst mergeProps = (source, target) => {\n  const newTarget = { ...target\n  };\n  newTarget.props = Object.assign(source.props, target.props);\n  return newTarget;\n};\n\nexport const nodesToString = (children, i18nOptions, i18n, i18nKey) => {\n  if (!children) return '';\n  let stringNode = '';\n  const childrenArray = getAsArray(children);\n  const keepArray = i18nOptions?.transSupportBasicHtmlNodes ? i18nOptions.transKeepBasicHtmlNodesFor ?? [] : [];\n  childrenArray.forEach((child, childIndex) => {\n    if (isString(child)) {\n      stringNode += `${child}`;\n      return;\n    }\n\n    if (isValidElement(child)) {\n      const {\n        props,\n        type\n      } = child;\n      const childPropsCount = Object.keys(props).length;\n      const shouldKeepChild = keepArray.indexOf(type) > -1;\n      const childChildren = props.children;\n\n      if (!childChildren && shouldKeepChild && !childPropsCount) {\n        stringNode += `<${type}/>`;\n        return;\n      }\n\n      if (!childChildren && (!shouldKeepChild || childPropsCount) || props.i18nIsDynamicList) {\n        stringNode += `<${childIndex}></${childIndex}>`;\n        return;\n      }\n\n      if (shouldKeepChild && childPropsCount === 1 && isString(childChildren)) {\n        stringNode += `<${type}>${childChildren}</${type}>`;\n        return;\n      }\n\n      const content = nodesToString(childChildren, i18nOptions, i18n, i18nKey);\n      stringNode += `<${childIndex}>${content}</${childIndex}>`;\n      return;\n    }\n\n    if (child === null) {\n      warn(i18n, 'TRANS_NULL_VALUE', `Passed in a null value as child`, {\n        i18nKey\n      });\n      return;\n    }\n\n    if (isObject(child)) {\n      const {\n        format,\n        ...clone\n      } = child;\n      const keys = Object.keys(clone);\n\n      if (keys.length === 1) {\n        const value = format ? `${keys[0]}, ${format}` : keys[0];\n        stringNode += `{{${value}}}`;\n        return;\n      }\n\n      warn(i18n, 'TRANS_INVALID_OBJ', `Invalid child - Object should only have keys {{ value, format }} (format is optional).`, {\n        i18nKey,\n        child\n      });\n      return;\n    }\n\n    warn(i18n, 'TRANS_INVALID_VAR', `Passed in a variable like {number} - pass variables for interpolation as full objects like {{number}}.`, {\n      i18nKey,\n      child\n    });\n  });\n  return stringNode;\n};\n\nconst escapeLiteralLessThan = (str, keepArray = [], knownComponentsMap = {}) => {\n  if (!str) return str;\n  const knownNames = Object.keys(knownComponentsMap);\n  const allValidNames = [...keepArray, ...knownNames];\n  let result = '';\n  let i = 0;\n\n  while (i < str.length) {\n    if (str[i] === '<') {\n      let isValidTag = false;\n      const closingMatch = str.slice(i).match(/^<\\/(\\d+|[a-zA-Z][a-zA-Z0-9-]*)>/);\n\n      if (closingMatch) {\n        const tagName = closingMatch[1];\n\n        if (/^\\d+$/.test(tagName) || allValidNames.includes(tagName)) {\n          isValidTag = true;\n          result += closingMatch[0];\n          i += closingMatch[0].length;\n        }\n      }\n\n      if (!isValidTag) {\n        const openingMatch = str.slice(i).match(/^<(\\d+|[a-zA-Z][a-zA-Z0-9-]*)(\\s+[\\w-]+(?:=(?:\"[^\"]*\"|'[^']*'|[^\\s>]+))?)*\\s*(\\/)?>/);\n\n        if (openingMatch) {\n          const tagName = openingMatch[1];\n\n          if (/^\\d+$/.test(tagName) || allValidNames.includes(tagName)) {\n            isValidTag = true;\n            result += openingMatch[0];\n            i += openingMatch[0].length;\n          }\n        }\n      }\n\n      if (!isValidTag) {\n        result += '&lt;';\n        i += 1;\n      }\n    } else {\n      result += str[i];\n      i += 1;\n    }\n  }\n\n  return result;\n};\n\nconst renderNodes = (children, knownComponentsMap, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) => {\n  if (targetString === '') return [];\n  const keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];\n  const emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.map(keep => `<${keep}`).join('|')).test(targetString);\n  if (!children && !knownComponentsMap && !emptyChildrenButNeedsHandling && !shouldUnescape) return [targetString];\n  const data = knownComponentsMap ?? {};\n\n  const getData = childs => {\n    const childrenArray = getAsArray(childs);\n    childrenArray.forEach(child => {\n      if (isString(child)) return;\n      if (hasChildren(child)) getData(getChildren(child));else if (isObject(child) && !isValidElement(child)) Object.assign(data, child);\n    });\n  };\n\n  getData(children);\n  const escapedString = escapeLiteralLessThan(targetString, keepArray, data);\n  const ast = HTML.parse(`<0>${escapedString}</0>`);\n  const opts = { ...data,\n    ...combinedTOpts\n  };\n\n  const renderInner = (child, node, rootReactNode) => {\n    const childs = getChildren(child);\n    const mappedChildren = mapAST(childs, node.children, rootReactNode);\n    return hasValidReactChildren(childs) && mappedChildren.length === 0 || child.props?.i18nIsDynamicList ? childs : mappedChildren;\n  };\n\n  const pushTranslatedJSX = (child, inner, mem, i, isVoid) => {\n    if (child.dummy) {\n      child.children = inner;\n      mem.push(cloneElement(child, {\n        key: i\n      }, isVoid ? undefined : inner));\n    } else {\n      mem.push(...Children.map([child], c => {\n        const props = { ...c.props\n        };\n        delete props.i18nIsDynamicList;\n        return createElement(c.type, { ...props,\n          key: i,\n          ref: c.props.ref ?? c.ref\n        }, isVoid ? null : inner);\n      }));\n    }\n  };\n\n  const mapAST = (reactNode, astNode, rootReactNode) => {\n    const reactNodes = getAsArray(reactNode);\n    const astNodes = getAsArray(astNode);\n    return astNodes.reduce((mem, node, i) => {\n      const translationContent = node.children?.[0]?.content && i18n.services.interpolator.interpolate(node.children[0].content, opts, i18n.language);\n\n      if (node.type === 'tag') {\n        let tmp = reactNodes[parseInt(node.name, 10)];\n        if (!tmp && knownComponentsMap) tmp = knownComponentsMap[node.name];\n        if (rootReactNode.length === 1 && !tmp) tmp = rootReactNode[0][node.name];\n        if (!tmp) tmp = {};\n        const child = Object.keys(node.attrs).length !== 0 ? mergeProps({\n          props: node.attrs\n        }, tmp) : tmp;\n        const isElement = isValidElement(child);\n        const isValidTranslationWithChildren = isElement && hasChildren(node, true) && !node.voidElement;\n        const isEmptyTransWithHTML = emptyChildrenButNeedsHandling && isObject(child) && child.dummy && !isElement;\n        const isKnownComponent = isObject(knownComponentsMap) && Object.hasOwnProperty.call(knownComponentsMap, node.name);\n\n        if (isString(child)) {\n          const value = i18n.services.interpolator.interpolate(child, opts, i18n.language);\n          mem.push(value);\n        } else if (hasChildren(child) || isValidTranslationWithChildren) {\n          const inner = renderInner(child, node, rootReactNode);\n          pushTranslatedJSX(child, inner, mem, i);\n        } else if (isEmptyTransWithHTML) {\n          const inner = mapAST(reactNodes, node.children, rootReactNode);\n          pushTranslatedJSX(child, inner, mem, i);\n        } else if (Number.isNaN(parseFloat(node.name))) {\n          if (isKnownComponent) {\n            const inner = renderInner(child, node, rootReactNode);\n            pushTranslatedJSX(child, inner, mem, i, node.voidElement);\n          } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {\n            if (node.voidElement) {\n              mem.push(createElement(node.name, {\n                key: `${node.name}-${i}`\n              }));\n            } else {\n              const inner = mapAST(reactNodes, node.children, rootReactNode);\n              mem.push(createElement(node.name, {\n                key: `${node.name}-${i}`\n              }, inner));\n            }\n          } else if (node.voidElement) {\n            mem.push(`<${node.name} />`);\n          } else {\n            const inner = mapAST(reactNodes, node.children, rootReactNode);\n            mem.push(`<${node.name}>${inner}</${node.name}>`);\n          }\n        } else if (isObject(child) && !isElement) {\n          const content = node.children[0] ? translationContent : null;\n          if (content) mem.push(content);\n        } else {\n          pushTranslatedJSX(child, translationContent, mem, i, node.children.length !== 1 || !translationContent);\n        }\n      } else if (node.type === 'text') {\n        const wrapTextNodes = i18nOptions.transWrapTextNodes;\n        const content = shouldUnescape ? i18nOptions.unescape(i18n.services.interpolator.interpolate(node.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node.content, opts, i18n.language);\n\n        if (wrapTextNodes) {\n          mem.push(createElement(wrapTextNodes, {\n            key: `${node.name}-${i}`\n          }, content));\n        } else {\n          mem.push(content);\n        }\n      }\n\n      return mem;\n    }, []);\n  };\n\n  const result = mapAST([{\n    dummy: true,\n    children: children || []\n  }], ast, getAsArray(children || []));\n  return getChildren(result[0]);\n};\n\nconst fixComponentProps = (component, index, translation) => {\n  const componentKey = component.key || index;\n  const comp = cloneElement(component, {\n    key: componentKey\n  });\n\n  if (!comp.props || !comp.props.children || translation.indexOf(`${index}/>`) < 0 && translation.indexOf(`${index} />`) < 0) {\n    return comp;\n  }\n\n  function Componentized() {\n    return createElement(Fragment, null, comp);\n  }\n\n  return createElement(Componentized, {\n    key: componentKey\n  });\n};\n\nconst generateArrayComponents = (components, translation) => components.map((c, index) => fixComponentProps(c, index, translation));\n\nconst generateObjectComponents = (components, translation) => {\n  const componentMap = {};\n  Object.keys(components).forEach(c => {\n    Object.assign(componentMap, {\n      [c]: fixComponentProps(components[c], c, translation)\n    });\n  });\n  return componentMap;\n};\n\nconst generateComponents = (components, translation, i18n, i18nKey) => {\n  if (!components) return null;\n\n  if (Array.isArray(components)) {\n    return generateArrayComponents(components, translation);\n  }\n\n  if (isObject(components)) {\n    return generateObjectComponents(components, translation);\n  }\n\n  warnOnce(i18n, 'TRANS_INVALID_COMPONENTS', `<Trans /> \"components\" prop expects an object or array`, {\n    i18nKey\n  });\n  return null;\n};\n\nconst isComponentsMap = object => {\n  if (!isObject(object)) return false;\n  if (Array.isArray(object)) return false;\n  return Object.keys(object).reduce((acc, key) => acc && Number.isNaN(Number.parseFloat(key)), true);\n};\n\nexport function Trans({\n  children,\n  count,\n  parent,\n  i18nKey,\n  context,\n  tOptions = {},\n  values,\n  defaults,\n  components,\n  ns,\n  i18n: i18nFromProps,\n  t: tFromProps,\n  shouldUnescape,\n  ...additionalProps\n}) {\n  const i18n = i18nFromProps || getI18n();\n\n  if (!i18n) {\n    warnOnce(i18n, 'NO_I18NEXT_INSTANCE', `Trans: You need to pass in an i18next instance using i18nextReactModule`, {\n      i18nKey\n    });\n    return children;\n  }\n\n  const t = tFromProps || i18n.t.bind(i18n) || (k => k);\n\n  const reactI18nextOptions = { ...getDefaults(),\n    ...i18n.options?.react\n  };\n  let namespaces = ns || t.ns || i18n.options?.defaultNS;\n  namespaces = isString(namespaces) ? [namespaces] : namespaces || ['translation'];\n  const nodeAsString = nodesToString(children, reactI18nextOptions, i18n, i18nKey);\n  const defaultValue = defaults || tOptions?.defaultValue || nodeAsString || reactI18nextOptions.transEmptyNodeValue || (typeof i18nKey === 'function' ? keyFromSelector(i18nKey) : i18nKey);\n  const {\n    hashTransKey\n  } = reactI18nextOptions;\n  const key = i18nKey || (hashTransKey ? hashTransKey(nodeAsString || defaultValue) : nodeAsString || defaultValue);\n\n  if (i18n.options?.interpolation?.defaultVariables) {\n    values = values && Object.keys(values).length > 0 ? { ...values,\n      ...i18n.options.interpolation.defaultVariables\n    } : { ...i18n.options.interpolation.defaultVariables\n    };\n  }\n\n  const interpolationOverride = values || count !== undefined && !i18n.options?.interpolation?.alwaysFormat || !children ? tOptions.interpolation : {\n    interpolation: { ...tOptions.interpolation,\n      prefix: '#$?',\n      suffix: '?$#'\n    }\n  };\n  const combinedTOpts = { ...tOptions,\n    context: context || tOptions.context,\n    count,\n    ...values,\n    ...interpolationOverride,\n    defaultValue: defaults || tOptions?.defaultValue,\n    ns: namespaces\n  };\n  let translation = key ? t(key, combinedTOpts) : defaultValue;\n  if (translation === key && defaultValue) translation = defaultValue;\n  const generatedComponents = generateComponents(components, translation, i18n, i18nKey);\n  let indexedChildren = generatedComponents || children;\n  let componentsMap = null;\n\n  if (isComponentsMap(generatedComponents)) {\n    componentsMap = generatedComponents;\n    indexedChildren = children;\n  }\n\n  const content = renderNodes(indexedChildren, componentsMap, translation, i18n, reactI18nextOptions, combinedTOpts, shouldUnescape);\n  const useAsParent = parent ?? reactI18nextOptions.defaultTransParent;\n  return useAsParent ? createElement(useAsParent, additionalProps, content) : content;\n}","map":{"version":3,"sources":["/Users/nicodanke/development/dizen/react-blog-template/node_modules/react-i18next/dist/es/TransWithoutContext.js"],"names":["Fragment","isValidElement","cloneElement","createElement","Children","keyFromSelector","HTML","isObject","isString","warn","warnOnce","getDefaults","getI18n","hasChildren","node","checkLength","base","props","children","length","getChildren","i18nIsDynamicList","getAsArray","hasValidReactChildren","Array","isArray","every","data","mergeProps","source","target","newTarget","Object","assign","nodesToString","i18nOptions","i18n","i18nKey","stringNode","childrenArray","keepArray","transSupportBasicHtmlNodes","transKeepBasicHtmlNodesFor","forEach","child","childIndex","type","childPropsCount","keys","shouldKeepChild","indexOf","childChildren","content","format","clone","value","escapeLiteralLessThan","str","knownComponentsMap","knownNames","allValidNames","result","i","isValidTag","closingMatch","slice","match","tagName","test","includes","openingMatch","renderNodes","targetString","combinedTOpts","shouldUnescape","emptyChildrenButNeedsHandling","RegExp","map","keep","join","getData","childs","escapedString","ast","parse","opts","renderInner","rootReactNode","mappedChildren","mapAST","pushTranslatedJSX","inner","mem","isVoid","dummy","push","key","undefined","c","ref","reactNode","astNode","reactNodes","astNodes","reduce","translationContent","services","interpolator","interpolate","language","tmp","parseInt","name","attrs","isElement","isValidTranslationWithChildren","voidElement","isEmptyTransWithHTML","isKnownComponent","hasOwnProperty","call","Number","isNaN","parseFloat","wrapTextNodes","transWrapTextNodes","unescape","fixComponentProps","component","index","translation","componentKey","comp","Componentized","generateArrayComponents","components","generateObjectComponents","componentMap","generateComponents","isComponentsMap","object","acc","Trans","count","parent","context","tOptions","values","defaults","ns","i18nFromProps","t","tFromProps","additionalProps","bind","k","reactI18nextOptions","options","react","namespaces","defaultNS","nodeAsString","defaultValue","transEmptyNodeValue","hashTransKey","interpolation","defaultVariables","interpolationOverride","alwaysFormat","prefix","suffix","generatedComponents","indexedChildren","componentsMap","useAsParent","defaultTransParent"],"mappings":"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","sourcesContent":["import { Fragment, isValidElement, cloneElement, createElement, Children } from 'react';\nimport { keyFromSelector } from 'i18next';\nimport HTML from 'html-parse-stringify';\nimport { isObject, isString, warn, warnOnce } from './utils.js';\nimport { getDefaults } from './defaults.js';\nimport { getI18n } from './i18nInstance.js';\nconst hasChildren = (node, checkLength) => {\n  if (!node) return false;\n  const base = node.props?.children ?? node.children;\n  if (checkLength) return base.length > 0;\n  return !!base;\n};\nconst getChildren = node => {\n  if (!node) return [];\n  const children = node.props?.children ?? node.children;\n  return node.props?.i18nIsDynamicList ? getAsArray(children) : children;\n};\nconst hasValidReactChildren = children => Array.isArray(children) && children.every(isValidElement);\nconst getAsArray = data => Array.isArray(data) ? data : [data];\nconst mergeProps = (source, target) => {\n  const newTarget = {\n    ...target\n  };\n  newTarget.props = Object.assign(source.props, target.props);\n  return newTarget;\n};\nexport const nodesToString = (children, i18nOptions, i18n, i18nKey) => {\n  if (!children) return '';\n  let stringNode = '';\n  const childrenArray = getAsArray(children);\n  const keepArray = i18nOptions?.transSupportBasicHtmlNodes ? i18nOptions.transKeepBasicHtmlNodesFor ?? [] : [];\n  childrenArray.forEach((child, childIndex) => {\n    if (isString(child)) {\n      stringNode += `${child}`;\n      return;\n    }\n    if (isValidElement(child)) {\n      const {\n        props,\n        type\n      } = child;\n      const childPropsCount = Object.keys(props).length;\n      const shouldKeepChild = keepArray.indexOf(type) > -1;\n      const childChildren = props.children;\n      if (!childChildren && shouldKeepChild && !childPropsCount) {\n        stringNode += `<${type}/>`;\n        return;\n      }\n      if (!childChildren && (!shouldKeepChild || childPropsCount) || props.i18nIsDynamicList) {\n        stringNode += `<${childIndex}></${childIndex}>`;\n        return;\n      }\n      if (shouldKeepChild && childPropsCount === 1 && isString(childChildren)) {\n        stringNode += `<${type}>${childChildren}</${type}>`;\n        return;\n      }\n      const content = nodesToString(childChildren, i18nOptions, i18n, i18nKey);\n      stringNode += `<${childIndex}>${content}</${childIndex}>`;\n      return;\n    }\n    if (child === null) {\n      warn(i18n, 'TRANS_NULL_VALUE', `Passed in a null value as child`, {\n        i18nKey\n      });\n      return;\n    }\n    if (isObject(child)) {\n      const {\n        format,\n        ...clone\n      } = child;\n      const keys = Object.keys(clone);\n      if (keys.length === 1) {\n        const value = format ? `${keys[0]}, ${format}` : keys[0];\n        stringNode += `{{${value}}}`;\n        return;\n      }\n      warn(i18n, 'TRANS_INVALID_OBJ', `Invalid child - Object should only have keys {{ value, format }} (format is optional).`, {\n        i18nKey,\n        child\n      });\n      return;\n    }\n    warn(i18n, 'TRANS_INVALID_VAR', `Passed in a variable like {number} - pass variables for interpolation as full objects like {{number}}.`, {\n      i18nKey,\n      child\n    });\n  });\n  return stringNode;\n};\nconst escapeLiteralLessThan = (str, keepArray = [], knownComponentsMap = {}) => {\n  if (!str) return str;\n  const knownNames = Object.keys(knownComponentsMap);\n  const allValidNames = [...keepArray, ...knownNames];\n  let result = '';\n  let i = 0;\n  while (i < str.length) {\n    if (str[i] === '<') {\n      let isValidTag = false;\n      const closingMatch = str.slice(i).match(/^<\\/(\\d+|[a-zA-Z][a-zA-Z0-9-]*)>/);\n      if (closingMatch) {\n        const tagName = closingMatch[1];\n        if (/^\\d+$/.test(tagName) || allValidNames.includes(tagName)) {\n          isValidTag = true;\n          result += closingMatch[0];\n          i += closingMatch[0].length;\n        }\n      }\n      if (!isValidTag) {\n        const openingMatch = str.slice(i).match(/^<(\\d+|[a-zA-Z][a-zA-Z0-9-]*)(\\s+[\\w-]+(?:=(?:\"[^\"]*\"|'[^']*'|[^\\s>]+))?)*\\s*(\\/)?>/);\n        if (openingMatch) {\n          const tagName = openingMatch[1];\n          if (/^\\d+$/.test(tagName) || allValidNames.includes(tagName)) {\n            isValidTag = true;\n            result += openingMatch[0];\n            i += openingMatch[0].length;\n          }\n        }\n      }\n      if (!isValidTag) {\n        result += '&lt;';\n        i += 1;\n      }\n    } else {\n      result += str[i];\n      i += 1;\n    }\n  }\n  return result;\n};\nconst renderNodes = (children, knownComponentsMap, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) => {\n  if (targetString === '') return [];\n  const keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];\n  const emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.map(keep => `<${keep}`).join('|')).test(targetString);\n  if (!children && !knownComponentsMap && !emptyChildrenButNeedsHandling && !shouldUnescape) return [targetString];\n  const data = knownComponentsMap ?? {};\n  const getData = childs => {\n    const childrenArray = getAsArray(childs);\n    childrenArray.forEach(child => {\n      if (isString(child)) return;\n      if (hasChildren(child)) getData(getChildren(child));else if (isObject(child) && !isValidElement(child)) Object.assign(data, child);\n    });\n  };\n  getData(children);\n  const escapedString = escapeLiteralLessThan(targetString, keepArray, data);\n  const ast = HTML.parse(`<0>${escapedString}</0>`);\n  const opts = {\n    ...data,\n    ...combinedTOpts\n  };\n  const renderInner = (child, node, rootReactNode) => {\n    const childs = getChildren(child);\n    const mappedChildren = mapAST(childs, node.children, rootReactNode);\n    return hasValidReactChildren(childs) && mappedChildren.length === 0 || child.props?.i18nIsDynamicList ? childs : mappedChildren;\n  };\n  const pushTranslatedJSX = (child, inner, mem, i, isVoid) => {\n    if (child.dummy) {\n      child.children = inner;\n      mem.push(cloneElement(child, {\n        key: i\n      }, isVoid ? undefined : inner));\n    } else {\n      mem.push(...Children.map([child], c => {\n        const props = {\n          ...c.props\n        };\n        delete props.i18nIsDynamicList;\n        return createElement(c.type, {\n          ...props,\n          key: i,\n          ref: c.props.ref ?? c.ref\n        }, isVoid ? null : inner);\n      }));\n    }\n  };\n  const mapAST = (reactNode, astNode, rootReactNode) => {\n    const reactNodes = getAsArray(reactNode);\n    const astNodes = getAsArray(astNode);\n    return astNodes.reduce((mem, node, i) => {\n      const translationContent = node.children?.[0]?.content && i18n.services.interpolator.interpolate(node.children[0].content, opts, i18n.language);\n      if (node.type === 'tag') {\n        let tmp = reactNodes[parseInt(node.name, 10)];\n        if (!tmp && knownComponentsMap) tmp = knownComponentsMap[node.name];\n        if (rootReactNode.length === 1 && !tmp) tmp = rootReactNode[0][node.name];\n        if (!tmp) tmp = {};\n        const child = Object.keys(node.attrs).length !== 0 ? mergeProps({\n          props: node.attrs\n        }, tmp) : tmp;\n        const isElement = isValidElement(child);\n        const isValidTranslationWithChildren = isElement && hasChildren(node, true) && !node.voidElement;\n        const isEmptyTransWithHTML = emptyChildrenButNeedsHandling && isObject(child) && child.dummy && !isElement;\n        const isKnownComponent = isObject(knownComponentsMap) && Object.hasOwnProperty.call(knownComponentsMap, node.name);\n        if (isString(child)) {\n          const value = i18n.services.interpolator.interpolate(child, opts, i18n.language);\n          mem.push(value);\n        } else if (hasChildren(child) || isValidTranslationWithChildren) {\n          const inner = renderInner(child, node, rootReactNode);\n          pushTranslatedJSX(child, inner, mem, i);\n        } else if (isEmptyTransWithHTML) {\n          const inner = mapAST(reactNodes, node.children, rootReactNode);\n          pushTranslatedJSX(child, inner, mem, i);\n        } else if (Number.isNaN(parseFloat(node.name))) {\n          if (isKnownComponent) {\n            const inner = renderInner(child, node, rootReactNode);\n            pushTranslatedJSX(child, inner, mem, i, node.voidElement);\n          } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {\n            if (node.voidElement) {\n              mem.push(createElement(node.name, {\n                key: `${node.name}-${i}`\n              }));\n            } else {\n              const inner = mapAST(reactNodes, node.children, rootReactNode);\n              mem.push(createElement(node.name, {\n                key: `${node.name}-${i}`\n              }, inner));\n            }\n          } else if (node.voidElement) {\n            mem.push(`<${node.name} />`);\n          } else {\n            const inner = mapAST(reactNodes, node.children, rootReactNode);\n            mem.push(`<${node.name}>${inner}</${node.name}>`);\n          }\n        } else if (isObject(child) && !isElement) {\n          const content = node.children[0] ? translationContent : null;\n          if (content) mem.push(content);\n        } else {\n          pushTranslatedJSX(child, translationContent, mem, i, node.children.length !== 1 || !translationContent);\n        }\n      } else if (node.type === 'text') {\n        const wrapTextNodes = i18nOptions.transWrapTextNodes;\n        const content = shouldUnescape ? i18nOptions.unescape(i18n.services.interpolator.interpolate(node.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node.content, opts, i18n.language);\n        if (wrapTextNodes) {\n          mem.push(createElement(wrapTextNodes, {\n            key: `${node.name}-${i}`\n          }, content));\n        } else {\n          mem.push(content);\n        }\n      }\n      return mem;\n    }, []);\n  };\n  const result = mapAST([{\n    dummy: true,\n    children: children || []\n  }], ast, getAsArray(children || []));\n  return getChildren(result[0]);\n};\nconst fixComponentProps = (component, index, translation) => {\n  const componentKey = component.key || index;\n  const comp = cloneElement(component, {\n    key: componentKey\n  });\n  if (!comp.props || !comp.props.children || translation.indexOf(`${index}/>`) < 0 && translation.indexOf(`${index} />`) < 0) {\n    return comp;\n  }\n  function Componentized() {\n    return createElement(Fragment, null, comp);\n  }\n  return createElement(Componentized, {\n    key: componentKey\n  });\n};\nconst generateArrayComponents = (components, translation) => components.map((c, index) => fixComponentProps(c, index, translation));\nconst generateObjectComponents = (components, translation) => {\n  const componentMap = {};\n  Object.keys(components).forEach(c => {\n    Object.assign(componentMap, {\n      [c]: fixComponentProps(components[c], c, translation)\n    });\n  });\n  return componentMap;\n};\nconst generateComponents = (components, translation, i18n, i18nKey) => {\n  if (!components) return null;\n  if (Array.isArray(components)) {\n    return generateArrayComponents(components, translation);\n  }\n  if (isObject(components)) {\n    return generateObjectComponents(components, translation);\n  }\n  warnOnce(i18n, 'TRANS_INVALID_COMPONENTS', `<Trans /> \"components\" prop expects an object or array`, {\n    i18nKey\n  });\n  return null;\n};\nconst isComponentsMap = object => {\n  if (!isObject(object)) return false;\n  if (Array.isArray(object)) return false;\n  return Object.keys(object).reduce((acc, key) => acc && Number.isNaN(Number.parseFloat(key)), true);\n};\nexport function Trans({\n  children,\n  count,\n  parent,\n  i18nKey,\n  context,\n  tOptions = {},\n  values,\n  defaults,\n  components,\n  ns,\n  i18n: i18nFromProps,\n  t: tFromProps,\n  shouldUnescape,\n  ...additionalProps\n}) {\n  const i18n = i18nFromProps || getI18n();\n  if (!i18n) {\n    warnOnce(i18n, 'NO_I18NEXT_INSTANCE', `Trans: You need to pass in an i18next instance using i18nextReactModule`, {\n      i18nKey\n    });\n    return children;\n  }\n  const t = tFromProps || i18n.t.bind(i18n) || (k => k);\n  const reactI18nextOptions = {\n    ...getDefaults(),\n    ...i18n.options?.react\n  };\n  let namespaces = ns || t.ns || i18n.options?.defaultNS;\n  namespaces = isString(namespaces) ? [namespaces] : namespaces || ['translation'];\n  const nodeAsString = nodesToString(children, reactI18nextOptions, i18n, i18nKey);\n  const defaultValue = defaults || tOptions?.defaultValue || nodeAsString || reactI18nextOptions.transEmptyNodeValue || (typeof i18nKey === 'function' ? keyFromSelector(i18nKey) : i18nKey);\n  const {\n    hashTransKey\n  } = reactI18nextOptions;\n  const key = i18nKey || (hashTransKey ? hashTransKey(nodeAsString || defaultValue) : nodeAsString || defaultValue);\n  if (i18n.options?.interpolation?.defaultVariables) {\n    values = values && Object.keys(values).length > 0 ? {\n      ...values,\n      ...i18n.options.interpolation.defaultVariables\n    } : {\n      ...i18n.options.interpolation.defaultVariables\n    };\n  }\n  const interpolationOverride = values || count !== undefined && !i18n.options?.interpolation?.alwaysFormat || !children ? tOptions.interpolation : {\n    interpolation: {\n      ...tOptions.interpolation,\n      prefix: '#$?',\n      suffix: '?$#'\n    }\n  };\n  const combinedTOpts = {\n    ...tOptions,\n    context: context || tOptions.context,\n    count,\n    ...values,\n    ...interpolationOverride,\n    defaultValue: defaults || tOptions?.defaultValue,\n    ns: namespaces\n  };\n  let translation = key ? t(key, combinedTOpts) : defaultValue;\n  if (translation === key && defaultValue) translation = defaultValue;\n  const generatedComponents = generateComponents(components, translation, i18n, i18nKey);\n  let indexedChildren = generatedComponents || children;\n  let componentsMap = null;\n  if (isComponentsMap(generatedComponents)) {\n    componentsMap = generatedComponents;\n    indexedChildren = children;\n  }\n  const content = renderNodes(indexedChildren, componentsMap, translation, i18n, reactI18nextOptions, combinedTOpts, shouldUnescape);\n  const useAsParent = parent ?? reactI18nextOptions.defaultTransParent;\n  return useAsParent ? createElement(useAsParent, additionalProps, content) : content;\n}"]},"metadata":{},"sourceType":"module"}